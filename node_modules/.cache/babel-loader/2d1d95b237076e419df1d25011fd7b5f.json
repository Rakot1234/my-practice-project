{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _bemCnFast = require('bem-cn-fast');\n\nvar _bemCnFast2 = _interopRequireDefault(_bemCnFast);\n\nvar _decamelize = require('decamelize');\n\nvar _decamelize2 = _interopRequireDefault(_decamelize);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * BEM class name factory.\n *\n * @typedef {Function} BemCn\n * @param {String|Object} [elementOrMods] Element name or hash object with mods.\n * @param {Object} [mods] Hash object with mods.\n * @returns {String}\n */\n\n/**\n * Extends `BemCn` factory with additional class proxy and theme.\n *\n * @param {BemCn} cn BemCn instance.\n * @param {String} className Additional class name.\n * @param {String} theme Theme name.\n * @returns {BemCn}\n */\n\n\nfunction getFunctionCn(cn, className, theme) {\n  var resultCn = function resultCn() {\n    var blockSelector = false;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length === 0) {\n      return cn({\n        theme: theme\n      }).toString() + (className ? ' ' + className : '');\n    }\n\n    if (_typeof(args[0]) === 'object') {\n      args[0].theme = theme;\n      blockSelector = true;\n    }\n\n    return cn.apply(cn, args) + (blockSelector && className ? ' ' + className : '');\n  };\n\n  resultCn.toString = function () {\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.warn('Deprecation: do not use cn() without parentheses');\n    }\n\n    return cn({\n      theme: theme\n    }).toString() + (className ? ' ' + className : '');\n  };\n\n  return resultCn;\n}\n/**\n * 1. Decorates `React.Component`. Extends `render` method for\n * apply as first argument `BemCn` instance that uses to\n * generate BEM class names.\n *\n * 2. Adds prop `theme`.\n *\n * 3. Adds prop `className` for provide additional `className`.\n *\n * @example\n * ```\n *     import cnDecorator from 'cn-decorator';\n *     const cn = cnDecorator.create(['on-color', 'on-white']);\n *\n *     \\@cn('my-block')\n *     class MyBlock extends React.Component {\n *          render(cn) {\n *              return (\n *                  <div className={ cn() } />\n *              );\n *          }\n *     }\n * ```\n *\n * Render result:\n *\n * ```\n *     <MyBlock />\n *     // <div class=\"my-block my-block_theme_on-color\"></div>\n *\n *     <MyBlock theme=\"on-white\" />\n *     // <div class=\"my-block my-block_theme_on-white\"></div>\n *\n *     <MyBlock className=\"additional-class\" />\n *     // <div class=\"my-block my-block_theme_on-color additional-class\"></div>\n * ```\n *\n * You can `CnDecorator` as dependency injector to flexibale change component\\'s composition.\n *\n * ```\n * // phone-input.jsx\n *\n * import cn from 'cn-decorator';\n * import Input from 'input';\n * import './input.css';\n *\n * // Source component with base BEM class name `phone-input` and composed `Input` component.\n * \\@cn('phone-input', Input)\n * class PhoneInput extends React.Component {\n *     render(cn, Input) {\n *          return <Input className={ cn() } />;\n *     }\n * }\n *\n * // my-phone-input.jsx\n *\n * import cn from 'cn-decorator'\n * import PhoneInput from 'phone-input';\n * import MyInput from 'my-input';\n * import './my-phone-input.css';\n *\n * // Extended component with base class name `my-phone-input`.\n * // Uses custom `MyInput` component inside.\n * \\@cn('my-phone-input', MyInput)\n * class MyPhoneInput extends PhoneInput {}\n * ```\n *\n * @typedef {Function} CnDecorator\n * @param {String} componentName Base CSS class name.\n * @param {...Function} [components] DI components.\n * @returns {Function}\n */\n\n/**\n * Factory `CnDecorator`.\n *\n * @param {Array.<String>} [themes] Optional themes list. Uses first theme as default.\n * @param {Object} [options] Optional params\n * @param {BemCn} [options.bem] Function bem-cn\n * @returns {CnDecorator}\n */\n\n\nfunction create(themes) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _bem = options.bem || _bemCnFast2.default;\n\n  function cn(componentName) {\n    for (var _len2 = arguments.length, components = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      components[_key2 - 1] = arguments[_key2];\n    }\n\n    function decorator(target) {\n      target._cn = _bem(typeof componentName === 'string' && componentName || (0, _decamelize2.default)(target.name, '-'));\n      target._cnComponents = components;\n\n      if (!target.prototype.hasOwnProperty('render')) {\n        return;\n      }\n\n      if (target.prototype.render.length === 0 && process.env.NODE_ENV !== 'production') {\n        throw new Error('Couldn\\'t decorate ' + componentName + ' because render method should contain at least one argument');\n      }\n\n      if (target.prototype.render.length >= 1) {\n        target.contextTypes = _extends({}, target.contextTypes, {\n          theme: _propTypes2.default.string\n        });\n        target.childContextTypes = _extends({}, target.childContextTypes, {\n          theme: _propTypes2.default.string\n        });\n        var originalGetChildContext = target.prototype.getChildContext;\n\n        target.prototype.getChildContext = function () {\n          return _extends({}, originalGetChildContext && originalGetChildContext.call(this), {\n            theme: this.context.theme\n          });\n        };\n\n        var originalRender = target.prototype.render;\n\n        target.prototype.render = function () {\n          var currentClassName = this.props.className;\n          var currentTheme = this.props.theme || this.context.theme || themes && themes[0];\n\n          if (!this._cnArgs || this._oldClassName !== currentClassName || this._oldTheme !== currentTheme) {\n            this._cnArgs = [getFunctionCn(this.constructor._cn, currentClassName, currentTheme)].concat(_toConsumableArray(this.constructor._cnComponents));\n            this._oldClassName = currentClassName;\n            this._oldTheme = currentTheme;\n          }\n\n          return originalRender.apply(this, this._cnArgs);\n        };\n      }\n    }\n\n    if (typeof componentName === 'function') {\n      return decorator(componentName);\n    }\n\n    return decorator;\n  }\n\n  cn.create = create;\n  return cn;\n}\n\nexports.default = create();","map":null,"metadata":{},"sourceType":"script"}